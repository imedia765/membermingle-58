import { supabase } from "@/integrations/supabase/client";
import { CleanMember } from "./dataTransform";

async function getNextCollectorNumber(): Promise<string> {
  console.log('Getting next collector number');
  
  const { data: lastCollector, error: queryError } = await supabase
    .from('collectors')
    .select('number')
    .order('number', { ascending: false })
    .limit(1)
    .maybeSingle(); // Use maybeSingle to handle empty results

  if (queryError) {
    console.error('Error querying last collector:', queryError);
    throw new Error(`Failed to get last collector number: ${queryError.message}`);
  }

  const nextNumber = lastCollector 
    ? String(Number(lastCollector.number) + 1).padStart(2, '0')
    : '01';
    
  console.log('Next collector number:', nextNumber);
  return nextNumber;
}

async function ensureCollectorExists(collectorName: string): Promise<string> {
  console.log('Checking collector:', collectorName);
  
  try {
    // First try to find existing collector
    const { data: existingCollector, error: findError } = await supabase
      .from('collectors')
      .select('id')
      .eq('name', collectorName)
      .maybeSingle(); // Use maybeSingle to handle empty results

    if (findError) {
      console.error('Error finding collector:', findError);
      throw findError;
    }

    if (existingCollector) {
      console.log('Found existing collector:', existingCollector);
      return existingCollector.id;
    }

    // If not found, create new collector
    const nextNumber = await getNextCollectorNumber();
    
    // Handle special characters in collector names
    const nameParts = collectorName.split(/[\s&-]/); // Split on space, &, or -
    const prefix = nameParts
      .map(part => part.substring(0, 2).toUpperCase()) // Take first 2 chars of each part
      .join(''); // Join them together

    console.log('Creating new collector with prefix:', prefix, 'and number:', nextNumber);

    const { data: newCollector, error: insertError } = await supabase
      .from('collectors')
      .insert({
        name: collectorName,
        prefix: prefix,
        number: nextNumber,
      })
      .select('id')
      .single();

    if (insertError) {
      console.error('Error creating collector:', insertError);
      throw new Error(`Failed to create collector: ${insertError.message}`);
    }

    console.log('Created new collector:', newCollector);
    return newCollector.id;
  } catch (error) {
    console.error('Error in ensureCollectorExists:', error);
    throw error;
  }
}

export async function insertMemberData(transformedData: CleanMember[]) {
  console.log('Starting batch insert of member data');
  
  for (const member of transformedData) {
    try {
      // Ensure collector exists and get ID
      const collectorId = await ensureCollectorExists(member.collector);
      console.log('Using collector ID:', collectorId);

      // Insert member with empty member_number (trigger will generate it)
      const { data: memberData, error: memberError } = await supabase
        .from('members')
        .insert({
          collector_id: collectorId,
          full_name: member.name || member.fullName,
          address: member.address,
          status: 'active',
          verified: member.verified,
          member_number: '', // Will be generated by trigger
          email: member.email || null,
          gender: member.gender || null,
          marital_status: member.maritalStatus || null,
          phone: member.mobileNo || null,
          date_of_birth: member.dateOfBirth || null,
          postcode: member.postCode || null,
          town: member.town || null
        })
        .select()
        .single();

      if (memberError) {
        console.error('Error inserting member:', memberError);
        throw memberError;
      }

      console.log('Successfully inserted member:', memberData);

      // Insert admin notes if any
      if (member.notes && Array.isArray(member.notes)) {
        const { error: notesError } = await supabase
          .from('admin_notes')
          .insert(
            member.notes.map((note: string) => ({
              member_id: memberData.id,
              note: note
            }))
          );

        if (notesError) {
          console.error('Error inserting notes:', notesError);
        }
      }

      console.log(`Successfully processed member: ${member.name || member.fullName}`);
    } catch (error) {
      console.error('Error processing member:', error);
      throw error;
    }
  }
}